// Code generated by schema-generate. DO NOT EDIT.

package output

import (
    "encoding/json"
    "errors"
    "bytes"
)

// APPLICATIONERRORDETAIL Code assigned by the recipient of a message to indicate a data validation error condition. 
type APPLICATIONERRORDETAIL struct {

  // Code specifying an application error.
  ApplicationErrorCode string `json:"applicationErrorCode,omitempty"`

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`
}

// APPLICATIONERRORINFORMATIONItemsItems 
type APPLICATIONERRORINFORMATIONItemsItems struct {

  // Code assigned by the recipient of a message to indicate a data validation error condition. 
  ApplicationErrorDetail *APPLICATIONERRORDETAIL `json:"applicationErrorDetail,omitempty"`
}

// AcceptanceDateOfGoodsDeclarationCustoms [2036] Date on which a Goods declaration is accepted by Customs in accordance with Customs legislation.
type AcceptanceDateOfGoodsDeclarationCustoms struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// AmountDueAmountPayable Amount to be paid.
type AmountDueAmountPayable struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// AmountReferenceCurrency The owing amount in the currency used as reference in the transaction.
type AmountReferenceCurrency struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// AmountToBePaidInAdvance Amount which is to be paid before goods are delivered or the service is rendered.
type AmountToBePaidInAdvance struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// BEGINNINGOFMESSAGE  A segment identifying the type and the reference number of the message to which the CUSRES is a response.
type BEGINNINGOFMESSAGE struct {

  // Identification of a document/message by its number and eventually its version or revision. 
  DocumentMessageIdentification *DOCUMENTMESSAGEIDENTIFICATION `json:"documentMessageIdentification,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`

  // Code indicating the function of the message.: (29) Accepted without amendment; (27) Not accepted; (6) Confirmation
  MessageFunctionCode string `json:"messageFunctionCode,omitempty"`
}

// CURRENCIES  A segment identifying currencies and the rate of exchange for a monetary amount identified within this group.
type CURRENCIES struct {

  // The usage to which a currency relates. 
  CurrencyDetails1 *CURRENCYDETAILS `json:"currencyDetails_1,omitempty"`

  // The usage to which a currency relates. 
  CurrencyDetails2 *CURRENCYDETAILS `json:"currencyDetails_2,omitempty"`

  // To specify the rate at which one specified currency is expressed in another specified currency.
  CurrencyExchangeRate float64 `json:"currencyExchangeRate,omitempty"`
}

// CURRENCYDETAILS The usage to which a currency relates. 
type CURRENCYDETAILS struct {

  // Code specifying a monetary unit.
  CurrencyIdentificationCode string `json:"currencyIdentificationCode,omitempty"`

  // To specify the value of the multiplication factor used in expressing currency units.
  CurrencyRate float64 `json:"currencyRate,omitempty"`

  // Code qualifying the type of currency.
  CurrencyTypeCodeQualifier string `json:"currencyTypeCodeQualifier,omitempty"`

  // Code qualifying the usage of a currency.
  CurrencyUsageCodeQualifier string `json:"currencyUsageCodeQualifier"`
}

// CUSTOMSSTATUSOFGOODS  A segment identifying goods in terms of customs identities, status and intended use.
type CUSTOMSSTATUSOFGOODS struct {

  // To specify a goods item within a consignment.
  GoodsItemNumber float64 `json:"goodsItemNumber"`
}

// CustomsDeclarationNumber [1426] Number, assigned or accepted by Customs, to identify a Goods declaration.
type CustomsDeclarationNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// CustomsDuty Duties laid down in the Customs tariff to which goods are liable on entering or leaving the Customs territory (CCC).
type CustomsDuty struct {

  // Code qualifying the function of a duty or tax or fee.: (5) Customs duty
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`
}

// CustomsOfficeOfClearance (3080) Place where Customs clearance procedure occur (CCC).
type CustomsOfficeOfClearance struct {

  // Code identifying the function of a location.: (22) Customs office of clearance
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`

  // Identification the first related location by code or name. 
  RelatedLocationOneIdentification *RELATEDLOCATIONONEIDENTIFICATION `json:"relatedLocationOneIdentification,omitempty"`
}

// CustomsReleaseCode A code associated to a requirement that must be presented to gain the release of goods by Customs.
type CustomsReleaseCode struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// CustomsValue [5032] Value declared for Customs purposes on those goods in a consignment which are subject to the same Customs procedure, and have the same tariff/statistical heading, country information and duty regime.
type CustomsValue struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DATETIMEPERIOD Date and/or time, or period relevant to the specified date/time/period type. 
type DATETIMEPERIOD struct {

  // Code specifying the representation of a date, time or period.: (203) CCYYMMDDHHMM
  DateOrTimeOrPeriodFormatCode string `json:"dateOrTimeOrPeriodFormatCode,omitempty"`

  // Code qualifying the function of a date, time or period.: (222) Presentation date, latest
  DateOrTimeOrPeriodFunctionCodeQualifier string `json:"dateOrTimeOrPeriodFunctionCodeQualifier,omitempty"`

  // The value of a date, a date and time, a time or of a period in a specified representation.
  DateOrTimeOrPeriodText string `json:"dateOrTimeOrPeriodText,omitempty"`
}

// DOCUMENTMESSAGEDETAILS Identification of document/message by number, status, source and/or language. 
type DOCUMENTMESSAGEDETAILS struct {

  // To identify a document.
  DocumentIdentifier string `json:"documentIdentifier,omitempty"`
}

// DOCUMENTMESSAGEIDENTIFICATION Identification of a document/message by its number and eventually its version or revision. 
type DOCUMENTMESSAGEIDENTIFICATION struct {

  // To identify a document.
  DocumentIdentifier string `json:"documentIdentifier,omitempty"`

  // To identify a revision.
  RevisionIdentifier string `json:"revisionIdentifier,omitempty"`

  // To identify a version.
  VersionIdentifier string `json:"versionIdentifier,omitempty"`
}

// DOCUMENTMESSAGENAME Identification of a type of document/message by code or name. Code preferred. 
type DOCUMENTMESSAGENAME struct {

  // Code specifying the document name.: (960) Single administrative document
  DocumentNameCode string `json:"documentNameCode,omitempty"`
}

// DUTYTAXFEEACCOUNTDETAIL Indication of account reference for duties, taxes and/or fees. 
type DUTYTAXFEEACCOUNTDETAIL struct {

  // Code specifying a duty or tax or fee account.
  DutyOrTaxOrFeeAccountCode string `json:"dutyOrTaxOrFeeAccountCode,omitempty"`
}

// DUTYTAXFEEDETAIL Rate of duty/tax/fee applicable to commodities or of tax applicable to services. 
type DUTYTAXFEEDETAIL struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode1 string `json:"codeListIdentificationCode_1,omitempty"`

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode2 string `json:"codeListIdentificationCode_2,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode1 string `json:"codeListResponsibleAgencyCode_1,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode2 string `json:"codeListResponsibleAgencyCode_2,omitempty"`

  // Rate of a duty or tax or fee.
  DutyOrTaxOrFeeRate string `json:"dutyOrTaxOrFeeRate,omitempty"`

  // Code specifying the basis for a duty or tax or fee rate.
  DutyOrTaxOrFeeRateBasisCode string `json:"dutyOrTaxOrFeeRateBasisCode,omitempty"`

  // Code specifying a rate of a duty or tax or fee.
  DutyOrTaxOrFeeRateCode string `json:"dutyOrTaxOrFeeRateCode,omitempty"`
}

// DUTYTAXFEETYPE Code and/or name identifying duty, tax or fee. 
type DUTYTAXFEETYPE struct {

  // Code specifying a type of duty, tax or fee.
  DutyOrTaxOrFeeTypeNameCode string `json:"dutyOrTaxOrFeeTypeNameCode"`
}

// DateAndTimeOfPreparation Date and time of preparation of the interchange.
type DateAndTimeOfPreparation struct {

  // Date the interchange was prepared.
  DateOfPreparation string `json:"dateOfPreparation,omitempty"`

  // Time the interchange was prepared.
  TimeOfPreparation string `json:"timeOfPreparation,omitempty"`
}

// DiscountAmount (5014) The amount specified is the discount amount.
type DiscountAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DutyAmount The amount of duty.
type DutyAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// DutyTaxOrFeeAmount Amount of duty, tax or fee.
type DutyTaxOrFeeAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// ERRORPOINTDETAILS  A segment identifying the location of an application error within the referenced message.
type ERRORPOINTDETAILS struct {

  // Indication of the point of error in a message. 
  ErrorPointDetails *ERRORPOINTDETAILS `json:"errorPointDetails,omitempty"`

  // To indicate the exact segment location of an application error within a message. 
  ErrorSegmentPointDetails *ERRORSEGMENTPOINTDETAILS `json:"errorSegmentPointDetails,omitempty"`
}

// ERRORSEGMENTPOINTDETAILS To indicate the exact segment location of an application error within a message. 
type ERRORSEGMENTPOINTDETAILS struct {

  // To identify the tag of a segment.
  SegmentTagIdentifier string `json:"segmentTagIdentifier,omitempty"`

  // Code specifying the source of a sequence identifier.
  SequenceIdentifierSourceCode float64 `json:"sequenceIdentifierSourceCode,omitempty"`

  // To identify a position in a sequence.
  SequencePositionIdentifier float64 `json:"sequencePositionIdentifier,omitempty"`
}

// EffectiveFromDateTime (2069) Date and/or time at which specified event or document becomes effective.
type EffectiveFromDateTime struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// FREETEXTItemsItems 
type FREETEXTItemsItems struct {

  // Code specifying the format of free text.
  FreeTextFormatCode string `json:"freeTextFormatCode,omitempty"`

  // Code specifying the function of free text.
  FreeTextFunctionCode string `json:"freeTextFunctionCode,omitempty"`

  // Code specifying the language name.
  LanguageNameCode string `json:"languageNameCode,omitempty"`

  // Free text; one to five lines. 
  TextLiteral *TEXTLITERAL `json:"textLiteral,omitempty"`

  // Coded reference to a standard text and its source. 
  TextReference *TEXTREFERENCE `json:"textReference,omitempty"`

  // Code qualifying the subject of the text.
  TextSubjectCodeQualifier string `json:"textSubjectCodeQualifier,omitempty"`
}

// GRP10 GRP10 -  A group of segments identifying currencies, a rate of exchange and an associated date related to the monetary amount.
type GRP10 struct {

  //  A segment identifying currencies and the rate of exchange for a monetary amount identified within this group.
  Currencies *CURRENCIES `json:"currencies,omitempty"`
}

// GRP11Items 
type GRP11Items struct {

  // Amount of duty, tax or fee.
  DutyTaxOrFeeAmount *DutyTaxOrFeeAmount `json:"dutyTaxOrFeeAmount"`

  // Total of each duty, tax or fee charged on the goods declaration (CCC).
  TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration *TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration `json:"totalOfEachDutyTaxOrFeeTypeCustomsDeclaration,omitempty"`
}

// GRP12Items 
type GRP12Items struct {

  //  A segment identifying goods in terms of customs identities, status and intended use.
  CustomsStatusOfGoods *CUSTOMSSTATUSOFGOODS `json:"customsStatusOfGoods,omitempty"`

  // GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
  DutyTaxAndFeeTotal *GRP13 `json:"dutyTaxAndFeeTotal,omitempty"`

  // GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
  IndividualDutyTaxOrFeeItems []*GRP13Items `json:"individualDutyTaxOrFeeItems,omitempty"`
}

// GRP13 GRP13 -  A group of segments identifying the customs amounts for- duties, taxes and fees related to the customs items identified in CST.
type GRP13 struct {

  // Duties laid down in the Customs tariff to which goods are liable on entering or leaving the Customs territory (CCC).
  CustomsDuty *CustomsDuty `json:"customsDuty,omitempty"`

  // [5032] Value declared for Customs purposes on those goods in a consignment which are subject to the same Customs procedure, and have the same tariff/statistical heading, country information and duty regime.
  CustomsValue *CustomsValue `json:"customsValue,omitempty"`

  // The amount of duty.
  DutyAmount *DutyAmount `json:"dutyAmount,omitempty"`

  // (5068) Total sum charged in respect of a single Invoice item in accordance with the terms of delivery.
  InvoiceItemAmount *InvoiceItemAmount `json:"invoiceItemAmount,omitempty"`

  // Amount in the currency of the licence to be written off from the total licence value.
  LicenceValueDeducted *LicenceValueDeducted `json:"licenceValueDeducted,omitempty"`

  // [5490] Amount in national currency resulting from the application, at the appropriate rate, of value added tax (or similar tax) to the invoice amount subject to such tax.
  ValueAddedTax *ValueAddedTax `json:"valueAddedTax,omitempty"`

  // First VAT value if, for the same rate of VAT, there are 1 to 3 different ways to set this value.
  Vat1stValue *VAT1stValue `json:"vat1stValue,omitempty"`
}

// GRP13Items 
type GRP13Items struct {

  // Amount of duty, tax or fee.
  DutyTaxOrFeeAmount *DutyTaxOrFeeAmount `json:"dutyTaxOrFeeAmount,omitempty"`

  // Individual duty, tax or fee charged on a single Customs item line of the goods declaration (CCC).
  IndividualDutyTaxOrFeeCustomsItem *IndividualDutyTaxOrFeeCustomsItem `json:"individualDutyTaxOrFeeCustomsItem,omitempty"`
}

// GRP3 GRP3 -  A group of segments identifying references, dates and locations related information.
type GRP3 struct {

  // A unique reference assigned by the originator.
  OriginatorsReference *OriginatorSReference `json:"originatorsReference,omitempty"`
}

// GRP4Items 
type GRP4Items struct {

  // Items:  A segment identifying the type of application errors within a message.
  ApplicationErrorInformationItems []*APPLICATIONERRORINFORMATIONItemsItems `json:"applicationErrorInformationItems,omitempty"`

  //  A segment identifying the location of an application error within the referenced message.
  ErrorPointDetails *ERRORPOINTDETAILS `json:"errorPointDetails,omitempty"`

  // Items:  A segment to provide explanation and/or supplementary information related to the specified application error.
  FreeTextItems []*FREETEXTItemsItems `json:"freeTextItems,omitempty"`

  // Items:  A segment to provide the references related to the application error.
  ReferenceItems []*REFERENCEItemsItems `json:"referenceItems,omitempty"`
}

// GRP6 GRP6 -  A group of segments specifying goods item details including status of goods, related references, package identification, details of transport, relevant parties, contacts, dates and/or times and location, general indicators, measurements, documentary requirements, monetary amounts, currencies and item taxes, fees and duties.
type GRP6 struct {

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountDueAmountPayable *GRP9 `json:"amountDueAmountPayable,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountReferenceCurrency *GRP9 `json:"amountReferenceCurrency,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  AmountToBePaidInAdvance *GRP9 `json:"amountToBePaidInAdvance,omitempty"`

  // GRP11 -  A group of segments identifying customs amounts for taxes, duties and fees related to a single customs declaration (e.g. a simplified customs declaration).
  CustomsAndDutiesPerDeclarationItems []*GRP11Items `json:"customsAndDutiesPerDeclarationItems,omitempty"`

  // GRP12 -  A group of segments identifying goods in terms of customs identities and customs amounts for duties, taxes and fees, following computation by customs.
  CustomsAndDutiesPerItemItems []*GRP12Items `json:"customsAndDutiesPerItemItems,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  CustomsValue *GRP9 `json:"customsValue,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  DiscountAmount *GRP9 `json:"discountAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  DutyAmount *GRP9 `json:"dutyAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  FreightCharge *GRP9 `json:"freightCharge,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  InsuranceChargesCustoms *GRP9 `json:"insuranceChargesCustoms,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  InvoiceTotalAmount *GRP9 `json:"invoiceTotalAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  MessageTotalDutyTaxFeeAmount *GRP9 `json:"messageTotalDutyTaxFeeAmount,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  OtherDeductibleCharges *GRP9 `json:"otherDeductibleCharges,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  OtherValuationChargesCustoms *GRP9 `json:"otherValuationChargesCustoms,omitempty"`

  // A set of documents, replacing the various (national) forms for Customs declaration within the EC, implemented on 01-01-1988.
  SingleAdministrativeDocument *SingleAdministrativeDocument `json:"singleAdministrativeDocument,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  TransportChargesCustoms *GRP9 `json:"transportChargesCustoms,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  ValueAddedTax *GRP9 `json:"valueAddedTax,omitempty"`

  // GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
  Vat1stValue *GRP9 `json:"vat1stValue,omitempty"`
}

// GRP9 GRP9 -  A group of segments identifying the monetary amount, currencies and the rate of exchange, against which duties, taxes or fees are being computed, per item.
type GRP9 struct {

  // GRP10 -  A group of segments identifying currencies, a rate of exchange and an associated date related to the monetary amount.
  Grp10 *GRP10 `json:"grp10,omitempty"`

  // Other charges deducted from the total invoice value.
  OtherDeductibleCharges *OtherDeductibleCharges `json:"otherDeductibleCharges,omitempty"`
}

// GoodsDeclarationNumber Reference number assigned to a goods declaration.
type GoodsDeclarationNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// ImportClearanceInstructionReferenceNumber Reference number of the import clearance instructions given by the consignor/consignee through different means.
type ImportClearanceInstructionReferenceNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// IndividualDutyTaxOrFeeCustomsItem Individual duty, tax or fee charged on a single Customs item line of the goods declaration (CCC).
type IndividualDutyTaxOrFeeCustomsItem struct {

  // To specify the basis on which a duty or tax or fee will be assessed.
  DutyOrTaxOrFeeAssessmentBasisQuantity string `json:"dutyOrTaxOrFeeAssessmentBasisQuantity,omitempty"`

  // Code qualifying the function of a duty or tax or fee.: (1) Individual duty, tax or fee (Customs item)
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`

  // Indication of account reference for duties, taxes and/or fees. 
  DutyTaxFeeAccountDetail *DUTYTAXFEEACCOUNTDETAIL `json:"dutyTaxFeeAccountDetail,omitempty"`

  // Rate of duty/tax/fee applicable to commodities or of tax applicable to services. 
  DutyTaxFeeDetail *DUTYTAXFEEDETAIL `json:"dutyTaxFeeDetail,omitempty"`

  // Code and/or name identifying duty, tax or fee. 
  DutyTaxFeeType *DUTYTAXFEETYPE `json:"dutyTaxFeeType,omitempty"`
}

// InsuranceChargesCustoms [5488] Amount of premium payable to the insurance company to insure the goods to the port or place of importation.
type InsuranceChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// InterchangeHeader Interchange Header Segment
type InterchangeHeader struct {

  // Date and time of preparation of the interchange.
  DateAndTimeOfPreparation *DateAndTimeOfPreparation `json:"dateAndTimeOfPreparation,omitempty"`

  // Unique reference assigned by the sender to an interchange.
  InterchangeControlReference string `json:"interchangeControlReference,omitempty"`

  // Identification of the Recipient of the interchange.
  InterchangeRecipient *InterchangeRecipient `json:"interchangeRecipient,omitempty"`

  // Identification of the sender of the interchange.
  InterchangeSender *InterchangeSender `json:"interchangeSender,omitempty"`

  // Identification of the agency controlling the syntax and indication of syntax level.
  Syntax *SYNTAX `json:"syntax,omitempty"`
}

// InterchangeRecipient Identification of the Recipient of the interchange.
type InterchangeRecipient struct {

  // Address for reverse routing.
  AddressForReverseRouting string `json:"addressForReverseRouting,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  PartnerIdentificationCodeQualifier string `json:"partnerIdentificationCodeQualifier,omitempty"`

  // Name or coded representation of the recipient of a data interchange.
  RecipientIdentification string `json:"recipientIdentification,omitempty"`
}

// InterchangeSender Identification of the sender of the interchange.
type InterchangeSender struct {

  // Address for reverse routing.
  AddressForReverseRouting string `json:"addressForReverseRouting,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  PartnerIdentificationCodeQualifier string `json:"partnerIdentificationCodeQualifier,omitempty"`

  // Name or coded representation of the sender of a data interchange.
  SenderIdentification string `json:"senderIdentification,omitempty"`
}

// InterchangeTrailer Close of the Interchange message.
type InterchangeTrailer struct {

  // Count either of the number of messages or, if used, of the number of functional groups in an interchange.
  InterchangeControlCount float64 `json:"interchangeControlCount,omitempty"`

  // Unique reference assigned by the sender to an interchange.
  InterchangeControlReference string `json:"interchangeControlReference,omitempty"`
}

// InvoiceItemAmount (5068) Total sum charged in respect of a single Invoice item in accordance with the terms of delivery.
type InvoiceItemAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// InvoiceTotalAmount [5444] Total sum charged in respect of one or more Invoices in accordance with the terms of delivery.
type InvoiceTotalAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// LOCATIONIDENTIFICATION Identification of a location by code or name. 
type LOCATIONIDENTIFICATION struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.: (109) GB, H.M. Customs & Excise
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying the name of the location.
  LocationNameCode string `json:"locationNameCode"`
}

// LicenceValueDeducted Amount in the currency of the licence to be written off from the total licence value.
type LicenceValueDeducted struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// LocationOfGoods [3384] Place where goods are located.
type LocationOfGoods struct {

  // Code identifying the function of a location.: (14) Location of goods
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`
}

// MAPPER1 
type MAPPER1 struct {

  // [2036] Date on which a Goods declaration is accepted by Customs in accordance with Customs legislation.
  AcceptanceDateOfGoodsDeclarationCustoms *AcceptanceDateOfGoodsDeclarationCustoms `json:"acceptanceDateOfGoodsDeclarationCustoms,omitempty"`

  //  A segment identifying the type and the reference number of the message to which the CUSRES is a response.
  BeginningOfMessage *BEGINNINGOFMESSAGE `json:"beginningOfMessage,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  CustomsDeclarationNumber *GRP3 `json:"customsDeclarationNumber,omitempty"`

  // (3080) Place where Customs clearance procedure occur (CCC).
  CustomsOfficeOfClearance *CustomsOfficeOfClearance `json:"customsOfficeOfClearance,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  CustomsReleaseCode *GRP3 `json:"customsReleaseCode,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  DeclarantUniqueConsignmentReference *GRP3 `json:"declarantUniqueConsignmentReference,omitempty"`

  // GRP6 -  A group of segments specifying goods item details including status of goods, related references, package identification, details of transport, relevant parties, contacts, dates and/or times and location, general indicators, measurements, documentary requirements, monetary amounts, currencies and item taxes, fees and duties.
  DeclarationResponseDetail *GRP6 `json:"declarationResponseDetail,omitempty"`

  // (2069) Date and/or time at which specified event or document becomes effective.
  EffectiveFromDateTime *EffectiveFromDateTime `json:"effectiveFromDateTime,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  GoodsDeclarationNumber *GRP3 `json:"goodsDeclarationNumber,omitempty"`

  // GRP4 -  A group of segments identifying an application error condition within a message to which the CUSRES is a response.
  Grp4 []*GRP4Items `json:"grp4,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  ImportClearanceInstructionReferenceNumber *GRP3 `json:"importClearanceInstructionReferenceNumber,omitempty"`

  // Interchange Header Segment
  InterchangeHeader *InterchangeHeader `json:"interchangeHeader,omitempty"`

  // Close of the Interchange message.
  InterchangeTrailer *InterchangeTrailer `json:"interchangeTrailer,omitempty"`

  // [3384] Place where goods are located.
  LocationOfGoods *LocationOfGoods `json:"locationOfGoods,omitempty"`

  //  A service segment starting and uniquely identifying a message. The message type code for the Customs response message is CUSRES.
  MessageHeader *MESSAGEHEADER `json:"messageHeader,omitempty"`

  //  A service segment ending a message, giving the total number of segments in the message (including the UNH & UNT) and the control reference number of the message.
  MessageTrailer *MESSAGETRAILER `json:"messageTrailer,omitempty"`

  // (3410) Place where document is signed or otherwise authenticated. Synonym: Place of issue of document.
  PlaceOfAuthenticationOfDocument *PlaceOfAuthenticationOfDocument `json:"placeOfAuthenticationOfDocument,omitempty"`

  // Latest date for presentation of a document.
  PresentationDateLatest *PresentationDateLatest `json:"presentationDateLatest,omitempty"`

  // GRP3 -  A group of segments identifying references, dates and locations related information.
  UniqueConsignmentReferenceNumber *GRP3 `json:"uniqueConsignmentReferenceNumber,omitempty"`
}

// MESSAGEHEADER  A service segment starting and uniquely identifying a message. The message type code for the Customs response message is CUSRES.
type MESSAGEHEADER struct {

  // Reference serving as a key to relate all subsequent transfers of data to the same business case or file.
  CommonAccessReference string `json:"commonAccessReference,omitempty"`

  // Identification of the type, version, etc. of the message being interchanged. 
  MessageIdentifier *MESSAGEIDENTIFIER `json:"messageIdentifier,omitempty"`

  // Unique message reference assigned by the sender.
  MessageReferenceNumber string `json:"messageReferenceNumber,omitempty"`
}

// MESSAGEIDENTIFIER Identification of the type, version, etc. of the message being interchanged. 
type MESSAGEIDENTIFIER struct {

  // Code, assigned by the association responsible for the design and maintenance of the message type concerned, which further identifies the message.
  AssociationAssignedCode string `json:"associationAssignedCode,omitempty"`

  // Code identifying a controlling agency.: (UN) UN/CEFACT
  ControllingAgencyCoded string `json:"controllingAgencyCoded,omitempty"`

  // Release number within the current message version number.: 
  MessageReleaseNumber string `json:"messageReleaseNumber,omitempty"`

  // Code identifying a type of message and assigned by its controlling agency.: (CUSRES) Customs response message
  MessageType string `json:"messageType,omitempty"`

  // Version number of a message type.: (D) Draft version/UN/EDIFACT Directory
  MessageVersionNumber string `json:"messageVersionNumber,omitempty"`
}

// MESSAGETRAILER  A service segment ending a message, giving the total number of segments in the message (including the UNH & UNT) and the control reference number of the message.
type MESSAGETRAILER struct {

  // Unique message reference assigned by the sender.
  MessageReferenceNumber string `json:"messageReferenceNumber,omitempty"`

  // The number of segments in a message body, plus the message header segment and message trailer segment.
  NumberOfSegmentsInAMessage float64 `json:"numberOfSegmentsInAMessage,omitempty"`
}

// MONETARYAMOUNT Amount of goods or services stated as a monetary amount in a specified currency. 
type MONETARYAMOUNT struct {

  // Code specifying a monetary unit.
  CurrencyIdentificationCode string `json:"currencyIdentificationCode,omitempty"`

  // To specify a monetary amount.
  MonetaryAmount float64 `json:"monetaryAmount,omitempty"`

  // Code qualifying the type of monetary amount.: (103) Other deductible charges
  MonetaryAmountTypeCodeQualifier string `json:"monetaryAmountTypeCodeQualifier,omitempty"`
}

// MessageTotalDutyTaxFeeAmount Total of all duty/tax/fee amounts.
type MessageTotalDutyTaxFeeAmount struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// OriginatorSReference A unique reference assigned by the originator.
type OriginatorSReference struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// OtherDeductibleCharges Other charges deducted from the total invoice value.
type OtherDeductibleCharges struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// OtherValuationChargesCustoms Other valuation charges which are payable by reason of the importation or sale of the goods in the Customs territory.
type OtherValuationChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// PlaceOfAuthenticationOfDocument (3410) Place where document is signed or otherwise authenticated. Synonym: Place of issue of document.
type PlaceOfAuthenticationOfDocument struct {

  // Code identifying the function of a location.: (44) Place of authentication of document
  LocationFunctionCodeQualifier string `json:"locationFunctionCodeQualifier,omitempty"`

  // Identification of a location by code or name. 
  LocationIdentification *LOCATIONIDENTIFICATION `json:"locationIdentification,omitempty"`

  // Identification the first related location by code or name. 
  RelatedLocationOneIdentification *RELATEDLOCATIONONEIDENTIFICATION `json:"relatedLocationOneIdentification,omitempty"`
}

// PresentationDateLatest Latest date for presentation of a document.
type PresentationDateLatest struct {

  // Date and/or time, or period relevant to the specified date/time/period type. 
  DateTimePeriod *DATETIMEPERIOD `json:"dateTimePeriod,omitempty"`
}

// REFERENCE Identification of a reference. 
type REFERENCE struct {

  // To identify a line of a document.
  DocumentLineIdentifier string `json:"documentLineIdentifier"`

  // Code qualifying a reference.: (ABO) Originator's reference
  ReferenceCodeQualifier string `json:"referenceCodeQualifier,omitempty"`

  // Identifies a reference.
  ReferenceIdentifier string `json:"referenceIdentifier"`
}

// REFERENCEItemsItems 
type REFERENCEItemsItems struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// RELATEDLOCATIONONEIDENTIFICATION Identification the first related location by code or name. 
type RELATEDLOCATIONONEIDENTIFICATION struct {

  // Code specifying first related location.
  FirstRelatedLocationNameCode string `json:"firstRelatedLocationNameCode,omitempty"`
}

// SYNTAX Identification of the agency controlling the syntax and indication of syntax level.
type SYNTAX struct {

  // Coded identification of the agency controlling a syntax and syntax level used in an interchange.
  SyntaxIdentifier string `json:"syntaxIdentifier,omitempty"`

  // Version number of the syntax identified in the syntax identifier (0001).
  SyntaxTypeVersionNumber string `json:"syntaxTypeVersionNumber,omitempty"`
}

// SingleAdministrativeDocument A set of documents, replacing the various (national) forms for Customs declaration within the EC, implemented on 01-01-1988.
type SingleAdministrativeDocument struct {

  // Identification of document/message by number, status, source and/or language. 
  DocumentMessageDetails *DOCUMENTMESSAGEDETAILS `json:"documentMessageDetails,omitempty"`

  // Identification of a type of document/message by code or name. Code preferred. 
  DocumentMessageName *DOCUMENTMESSAGENAME `json:"documentMessageName,omitempty"`
}

// TEXTLITERAL Free text; one to five lines. 
type TEXTLITERAL struct {

  // Free form text.
  FreeText1 string `json:"freeText_1,omitempty"`

  // Free form text.
  FreeText2 string `json:"freeText_2,omitempty"`

  // Free form text.
  FreeText3 string `json:"freeText_3,omitempty"`

  // Free form text.
  FreeText4 string `json:"freeText_4,omitempty"`

  // Free form text.
  FreeText5 string `json:"freeText_5,omitempty"`
}

// TEXTREFERENCE Coded reference to a standard text and its source. 
type TEXTREFERENCE struct {

  // Code identifying a user or association maintained code list.
  CodeListIdentificationCode string `json:"codeListIdentificationCode,omitempty"`

  // Code specifying the agency responsible for a code list.
  CodeListResponsibleAgencyCode string `json:"codeListResponsibleAgencyCode,omitempty"`

  // Code specifying free form text.
  FreeTextDescriptionCode string `json:"freeTextDescriptionCode,omitempty"`
}

// TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration Total of each duty, tax or fee charged on the goods declaration (CCC).
type TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration struct {

  // Code qualifying the function of a duty or tax or fee.: (3) Total of each duty, tax or fee type (Customs declaration)
  DutyOrTaxOrFeeFunctionCodeQualifier string `json:"dutyOrTaxOrFeeFunctionCodeQualifier,omitempty"`

  // Indication of account reference for duties, taxes and/or fees. 
  DutyTaxFeeAccountDetail *DUTYTAXFEEACCOUNTDETAIL `json:"dutyTaxFeeAccountDetail,omitempty"`

  // Code and/or name identifying duty, tax or fee. 
  DutyTaxFeeType *DUTYTAXFEETYPE `json:"dutyTaxFeeType,omitempty"`
}

// TransportChargesCustoms (5292) Cost incurred by shipper in moving goods, by whatever means, from one place to another under the terms of the contract of carriage, see UN/ECE Recommendation No 23. Synonym: freight charges (Customs).
type TransportChargesCustoms struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// UniqueConsignmentReferenceNumber (1202) Unique reference of a consignment (UCRN) used for identification purposes in documents and messages exchanged between parties in international trade. See also: Unique Identifier Code (UNIC) in UN/ECE Recommendation No. 8, March 1992.
type UniqueConsignmentReferenceNumber struct {

  // Identification of a reference. 
  Reference *REFERENCE `json:"reference,omitempty"`
}

// VAT1stValue First VAT value if, for the same rate of VAT, there are 1 to 3 different ways to set this value.
type VAT1stValue struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

// ValueAddedTax [5490] Amount in national currency resulting from the application, at the appropriate rate, of value added tax (or similar tax) to the invoice amount subject to such tax.
type ValueAddedTax struct {

  // Amount of goods or services stated as a monetary amount in a specified currency. 
  MonetaryAmount *MONETARYAMOUNT `json:"monetaryAmount,omitempty"`
}

func (strct *CURRENCYDETAILS) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "currencyIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.CurrencyIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "currencyRate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyRate\": ")
	if tmp, err := json.Marshal(strct.CurrencyRate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "currencyTypeCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyTypeCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.CurrencyTypeCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CurrencyUsageCodeQualifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "currencyUsageCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"currencyUsageCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.CurrencyUsageCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CURRENCYDETAILS) MAPPER1UnmarshalJSON(b []byte) error {
    currencyUsageCodeQualifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "currencyIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyIdentificationCode); err != nil {
                return err
             }
        case "currencyRate":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyRate); err != nil {
                return err
             }
        case "currencyTypeCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyTypeCodeQualifier); err != nil {
                return err
             }
        case "currencyUsageCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.CurrencyUsageCodeQualifier); err != nil {
                return err
             }
            currencyUsageCodeQualifierReceived = true
        }
    }
    // check if currencyUsageCodeQualifier (a required property) was received
    if !currencyUsageCodeQualifierReceived {
        return errors.New("\"currencyUsageCodeQualifier\" is required but was not present")
    }
    return nil
}

func (strct *CUSTOMSSTATUSOFGOODS) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "GoodsItemNumber" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "goodsItemNumber" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"goodsItemNumber\": ")
	if tmp, err := json.Marshal(strct.GoodsItemNumber); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CUSTOMSSTATUSOFGOODS) MAPPER1UnmarshalJSON(b []byte) error {
    goodsItemNumberReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "goodsItemNumber":
            if err := json.Unmarshal([]byte(v), &strct.GoodsItemNumber); err != nil {
                return err
             }
            goodsItemNumberReceived = true
        }
    }
    // check if goodsItemNumber (a required property) was received
    if !goodsItemNumberReceived {
        return errors.New("\"goodsItemNumber\" is required but was not present")
    }
    return nil
}

func (strct *DUTYTAXFEETYPE) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DutyOrTaxOrFeeTypeNameCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "dutyOrTaxOrFeeTypeNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dutyOrTaxOrFeeTypeNameCode\": ")
	if tmp, err := json.Marshal(strct.DutyOrTaxOrFeeTypeNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DUTYTAXFEETYPE) MAPPER1UnmarshalJSON(b []byte) error {
    dutyOrTaxOrFeeTypeNameCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dutyOrTaxOrFeeTypeNameCode":
            if err := json.Unmarshal([]byte(v), &strct.DutyOrTaxOrFeeTypeNameCode); err != nil {
                return err
             }
            dutyOrTaxOrFeeTypeNameCodeReceived = true
        }
    }
    // check if dutyOrTaxOrFeeTypeNameCode (a required property) was received
    if !dutyOrTaxOrFeeTypeNameCodeReceived {
        return errors.New("\"dutyOrTaxOrFeeTypeNameCode\" is required but was not present")
    }
    return nil
}

func (strct *GRP11Items) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DutyTaxOrFeeAmount" field is required
    if strct.DutyTaxOrFeeAmount == nil {
        return nil, errors.New("dutyTaxOrFeeAmount is a required field")
    }
    // Marshal the "dutyTaxOrFeeAmount" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"dutyTaxOrFeeAmount\": ")
	if tmp, err := json.Marshal(strct.DutyTaxOrFeeAmount); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "totalOfEachDutyTaxOrFeeTypeCustomsDeclaration" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"totalOfEachDutyTaxOrFeeTypeCustomsDeclaration\": ")
	if tmp, err := json.Marshal(strct.TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GRP11Items) MAPPER1UnmarshalJSON(b []byte) error {
    dutyTaxOrFeeAmountReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dutyTaxOrFeeAmount":
            if err := json.Unmarshal([]byte(v), &strct.DutyTaxOrFeeAmount); err != nil {
                return err
             }
            dutyTaxOrFeeAmountReceived = true
        case "totalOfEachDutyTaxOrFeeTypeCustomsDeclaration":
            if err := json.Unmarshal([]byte(v), &strct.TotalOfEachDutyTaxOrFeeTypeCustomsDeclaration); err != nil {
                return err
             }
        }
    }
    // check if dutyTaxOrFeeAmount (a required property) was received
    if !dutyTaxOrFeeAmountReceived {
        return errors.New("\"dutyTaxOrFeeAmount\" is required but was not present")
    }
    return nil
}

func (strct *LOCATIONIDENTIFICATION) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "codeListIdentificationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListIdentificationCode\": ")
	if tmp, err := json.Marshal(strct.CodeListIdentificationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "codeListResponsibleAgencyCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"codeListResponsibleAgencyCode\": ")
	if tmp, err := json.Marshal(strct.CodeListResponsibleAgencyCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "LocationNameCode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "locationNameCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"locationNameCode\": ")
	if tmp, err := json.Marshal(strct.LocationNameCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LOCATIONIDENTIFICATION) MAPPER1UnmarshalJSON(b []byte) error {
    locationNameCodeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "codeListIdentificationCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListIdentificationCode); err != nil {
                return err
             }
        case "codeListResponsibleAgencyCode":
            if err := json.Unmarshal([]byte(v), &strct.CodeListResponsibleAgencyCode); err != nil {
                return err
             }
        case "locationNameCode":
            if err := json.Unmarshal([]byte(v), &strct.LocationNameCode); err != nil {
                return err
             }
            locationNameCodeReceived = true
        }
    }
    // check if locationNameCode (a required property) was received
    if !locationNameCodeReceived {
        return errors.New("\"locationNameCode\" is required but was not present")
    }
    return nil
}

func (strct *REFERENCE) MAPPER1MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "DocumentLineIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "documentLineIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"documentLineIdentifier\": ")
	if tmp, err := json.Marshal(strct.DocumentLineIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "referenceCodeQualifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"referenceCodeQualifier\": ")
	if tmp, err := json.Marshal(strct.ReferenceCodeQualifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ReferenceIdentifier" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "referenceIdentifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"referenceIdentifier\": ")
	if tmp, err := json.Marshal(strct.ReferenceIdentifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *REFERENCE) MAPPER1UnmarshalJSON(b []byte) error {
    documentLineIdentifierReceived := false
    referenceIdentifierReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "documentLineIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.DocumentLineIdentifier); err != nil {
                return err
             }
            documentLineIdentifierReceived = true
        case "referenceCodeQualifier":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceCodeQualifier); err != nil {
                return err
             }
        case "referenceIdentifier":
            if err := json.Unmarshal([]byte(v), &strct.ReferenceIdentifier); err != nil {
                return err
             }
            referenceIdentifierReceived = true
        }
    }
    // check if documentLineIdentifier (a required property) was received
    if !documentLineIdentifierReceived {
        return errors.New("\"documentLineIdentifier\" is required but was not present")
    }
    // check if referenceIdentifier (a required property) was received
    if !referenceIdentifierReceived {
        return errors.New("\"referenceIdentifier\" is required but was not present")
    }
    return nil
}
